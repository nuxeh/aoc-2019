(use-modules (srfi srfi-1))

;(define (get-path cmds p)
;  (if (null? (car cmds))
;    p
;    ((navigate (car cmds))
;    (display (cdr cmds))
;    (display " ")
;    (get-path (cdr cmds) p))))

(define (navigate cmd acc)
  (display "[")
  (display cmd)
  (display "] ")
  (let ((pos (last acc)))
    (let ((x (string->number (string-copy cmd 1))))
      (let ((d (string-copy cmd 0 1)))
        (if (string=? d "U")
          (do ((i 1 (1+ i))) ((> i x))
            (append! acc (list (cons (car pos) (+ i (cdr pos)))))))
        (if (string=? d "D")
          (do ((i 1 (1+ i))) ((> i x))
            (append! acc (list (cons (car pos) (- i (cdr pos)))))))
        (if (string=? d "L")
          (do ((i 1 (1+ i))) ((> i x))
            (append! acc (list (cons (- i (car pos)) (cdr pos))))))
        (if (string=? d "R")
          (do ((i 1 (1+ i))) ((> i x))
            (append! acc (list (cons (+ i (car pos)) (cdr pos))))))
        (display acc)
        (newline)
        acc))))

;(define (walk cmd acc)
;  (append acc (list (navigate cmd (last acc)))))

(define (dcol z)
  (display z)
  (if (eq? (car z) (cdr z))
      #t
      #f))

(let ((p1 (read)))
  (let ((p2 (read)))
    (let ((i (string-split (symbol->string p1) #\,)))
    (let ((j (string-split (symbol->string p2) #\,)))
    (display i)
    (newline)
    (display j)
    (newline)
    (let ((p/1 (fold navigate (list (cons 0 0)) i)))
    (let ((p/2 (fold navigate (list (cons 0 0)) j)))
      (newline)
      (display p/1)
      (newline)
      (newline)
      (display p/2)
      (newline)
      (newline)

      (display (map (lambda (a) (member a p/2)) p/1))
    ))))))


